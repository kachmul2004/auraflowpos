{
  "situationalRules": [
    {
      "id": "kmp-versions-2025",
      "name": "KMP Library Versions (2025)",
      "filePattern": "**/*.gradle.kts",
      "rule": "Use these exact versions for Kotlin Multiplatform projects:\n- Kotlin: 2.2.21\n- Compose Multiplatform: 1.9.2\n- Ktor: 3.3.1\n- Koin: 4.1.0\n- Room: 2.7.0-alpha10\n- Coroutines: 1.9.0\n- Serialization: 1.7.3\n- Coil3: 3.0.4\n- Voyager: 1.1.0\n- Kermit: 2.0.4\n- Kotlinx DateTime: 0.6.1\n- KSP: 2.2.21-1.0.29\n\nALWAYS use these latest stable versions unless there's a specific compatibility issue."
    },
    {
      "id": "kmp-clean-architecture-2025",
      "name": "KMP Clean Architecture (Updated 2025)",
      "filePattern": "**/*.kt",
      "rule": "Follow Clean Architecture with these layers:\n\n1. **Domain Layer** (shared/commonMain/domain/):\n   - Pure Kotlin, NO platform dependencies\n   - Domain models (data classes with @Serializable)\n   - Repository interfaces\n   - Use cases (single responsibility, suspend functions)\n   - Business logic only\n\n2. **Data Layer** (shared/commonMain/data/):\n   - Repository implementations\n   - Data sources (remote/local)\n   - DTOs with mappers to domain models\n   - Room entities with @Entity\n   - Ktor API clients\n\n3. **Presentation Layer** (composeApp/commonMain/):\n   - Compose UI with @Composable functions\n   - ViewModels extending ViewModel\n   - UI State classes (immutable data classes)\n   - Screen-level composables\n   - Navigation with Voyager\n\n4. **Core Layer** (shared/commonMain/core/):\n   - DI modules (Koin)\n   - Utils (Result wrapper, UiText)\n   - Platform interfaces (expect/actual)\n   - Constants\n\nDependency flow: Presentation → Domain ← Data\nNEVER let domain depend on data or presentation."
    },
    {
      "id": "koin-di-4-1-best-practices",
      "name": "Koin 4.1.0 Best Practices",
      "filePattern": "**/*Module.kt",
      "rule": "Koin 4.1.0 best practices:\n\n```kotlin\n// Module definition\nval appModule = module {\n    // Singleton for repositories\n    single<ProductRepository> { ProductRepositoryImpl(get(), get()) }\n    \n    // Factory for use cases (new instance each time)\n    factory { GetProductsUseCase(get()) }\n    \n    // ViewModel with viewModelOf (Koin 4.0+)\n    viewModelOf(::POSViewModel)\n    // OR\n    viewModel { POSViewModel(get(), get()) }\n    \n    // Single with createdAtStart for eager initialization\n    single(createdAtStart = true) { Logger() }\n}\n\n// In commonMain, initialize Koin:\nfun initKoin() = startKoin {\n    modules(appModule, networkModule, databaseModule)\n}\n\n// In Composable, inject dependencies:\n@Composable\nfun MyScreen() {\n    val viewModel = koinViewModel<POSViewModel>()\n    // Use viewModel\n}\n```\n\nALWAYS:\n- Use constructor injection\n- Use single for stateful objects (repositories, database)\n- Use factory for stateless objects (use cases)\n- Use viewModelOf for ViewModels (cleaner syntax)\n- Group modules by feature/layer\n- NEVER use get() outside of Koin modules"
    },
    {
      "id": "compose-multiplatform-1-9-ui",
      "name": "Compose Multiplatform 1.9.2 UI Guidelines",
      "filePattern": "**/ui/**/*.kt",
      "rule": "Compose Multiplatform 1.9.2 best practices:\n\n```kotlin\n@Composable\nfun ProductCard(\n    product: Product,\n    onAddToCart: (Product) -> Unit,\n    modifier: Modifier = Modifier\n) {\n    Card(\n        onClick = { onAddToCart(product) },\n        modifier = modifier.fillMaxWidth()\n    ) {\n        Column(Modifier.padding(16.dp)) {\n            // Use AsyncImage from Coil3\n            AsyncImage(\n                model = product.imageUrl,\n                contentDescription = product.name,\n                modifier = Modifier.size(120.dp)\n            )\n            Text(product.name, style = MaterialTheme.typography.titleMedium)\n            Text(\"$${product.price}\", style = MaterialTheme.typography.bodyLarge)\n        }\n    }\n}\n```\n\nALWAYS:\n- Use Material3 components\n- Pass Modifier as last parameter with default value\n- Use remember { } for state that survives recomposition\n- Use LaunchedEffect for side effects\n- Use derivedStateOf for computed values\n- Hoist state up\n- Name composables with nouns (ProductCard, not ShowProduct)\n- Use preview annotations for development\n- Keep composables small (<100 lines)\n\nNEVER:\n- Mutate state directly in composables\n- Use GlobalScope for coroutines\n- Pass ViewModels to child composables (pass state + callbacks)\n- Use !! (use ?. with null handling)"
    },
    {
      "id": "viewmodel-state-management-2025",
      "name": "ViewModel + State Management (2025)",
      "filePattern": "**/*ViewModel.kt",
      "rule": "ViewModel best practices with StateFlow:\n\n```kotlin\nclass POSViewModel(\n    private val getProductsUseCase: GetProductsUseCase,\n    private val addToCartUseCase: AddToCartUseCase\n) : ViewModel() {\n    \n    private val _uiState = MutableStateFlow<POSUiState>(POSUiState.Loading)\n    val uiState: StateFlow<POSUiState> = _uiState.asStateFlow()\n    \n    init {\n        loadProducts()\n    }\n    \n    fun loadProducts() {\n        viewModelScope.launch {\n            _uiState.value = POSUiState.Loading\n            getProductsUseCase()\n                .onSuccess { products ->\n                    _uiState.value = POSUiState.Success(products)\n                }\n                .onFailure { error ->\n                    _uiState.value = POSUiState.Error(error.message ?: \"Unknown error\")\n                }\n        }\n    }\n    \n    fun addToCart(product: Product) {\n        viewModelScope.launch {\n            addToCartUseCase(product)\n        }\n    }\n}\n\n// UI State sealed interface\nsealed interface POSUiState {\n    data object Loading : POSUiState\n    data class Success(val products: List<Product>) : POSUiState\n    data class Error(val message: String) : POSUiState\n}\n```\n\nALWAYS:\n- Use StateFlow for UI state\n- Make _uiState private, expose public immutable version\n- Use sealed interface for UI state variants\n- Launch coroutines in viewModelScope\n- Handle loading, success, error states\n- Use data objects for stateless variants (Loading)\n- Inject use cases via constructor\n\nNEVER:\n- Expose MutableStateFlow publicly\n- Use LiveData (use StateFlow)\n- Pass Context to ViewModel\n- Do business logic in ViewModel (use use cases)"
    },
    {
      "id": "repository-pattern-2025",
      "name": "Repository Pattern (2025)",
      "filePattern": "**/repository/**/*.kt",
      "rule": "Repository implementation pattern:\n\n```kotlin\n// Interface in domain layer\ninterface ProductRepository {\n    suspend fun getProducts(): Result<List<Product>>\n    suspend fun getProductById(id: String): Result<Product>\n    suspend fun searchProducts(query: String): Result<List<Product>>\n    fun observeProducts(): Flow<List<Product>>\n}\n\n// Implementation in data layer\nclass ProductRepositoryImpl(\n    private val remoteDataSource: ProductRemoteDataSource,\n    private val localDataSource: ProductLocalDataSource\n) : ProductRepository {\n    \n    override suspend fun getProducts(): Result<List<Product>> = withContext(Dispatchers.IO) {\n        try {\n            // Try remote first\n            val remoteProducts = remoteDataSource.fetchProducts()\n            // Cache locally\n            localDataSource.saveProducts(remoteProducts)\n            Result.success(remoteProducts.map { it.toDomain() })\n        } catch (e: Exception) {\n            // Fallback to local cache\n            try {\n                val localProducts = localDataSource.getProducts()\n                Result.success(localProducts.map { it.toDomain() })\n            } catch (cacheError: Exception) {\n                Result.failure(e)\n            }\n        }\n    }\n    \n    override fun observeProducts(): Flow<List<Product>> {\n        return localDataSource.observeProducts()\n            .map { entities -> entities.map { it.toDomain() } }\n    }\n}\n```\n\nALWAYS:\n- Return Result<T> for operations that can fail\n- Return Flow<T> for observable data\n- Use withContext(Dispatchers.IO) for suspend functions\n- Implement offline-first pattern (remote → cache → local)\n- Map DTOs/Entities to domain models\n- Handle errors gracefully with Result\n\nNEVER:\n- Return null (use Result or nullable types explicitly)\n- Throw exceptions from repository (wrap in Result)\n- Mix domain models with DTOs/Entities"
    },
    {
      "id": "use-case-pattern-2025",
      "name": "Use Case Pattern (2025)",
      "filePattern": "**/usecase/**/*.kt",
      "rule": "Use case implementation pattern:\n\n```kotlin\nclass GetProductsUseCase(\n    private val productRepository: ProductRepository\n) {\n    suspend operator fun invoke(): Result<List<Product>> {\n        return productRepository.getProducts()\n            .map { products ->\n                products.filter { it.isActive }\n                    .sortedBy { it.name }\n            }\n    }\n}\n\n// For use cases with parameters:\nclass SearchProductsUseCase(\n    private val productRepository: ProductRepository\n) {\n    suspend operator fun invoke(query: String): Result<List<Product>> {\n        if (query.isBlank()) {\n            return Result.success(emptyList())\n        }\n        return productRepository.searchProducts(query)\n    }\n}\n\n// For Flow-based use cases:\nclass ObserveCartUseCase(\n    private val cartRepository: CartRepository\n) {\n    operator fun invoke(): Flow<Cart> {\n        return cartRepository.observeCart()\n    }\n}\n```\n\nALWAYS:\n- Single responsibility (one business operation)\n- Use operator fun invoke() for callable syntax\n- Keep use cases small and focused\n- Add business logic/validation here\n- Use suspend for async operations\n- Return Result<T> or Flow<T>\n- Name with verb + noun (GetProducts, AddToCart)\n\nNEVER:\n- Put UI logic in use cases\n- Create \"manager\" use cases\n- Access database/API directly (use repository)"
    },
    {
      "id": "ktor-3-3-networking",
      "name": "Ktor 3.3.1 Client Configuration",
      "filePattern": "**/network/**/*.kt",
      "rule": "Ktor 3.3.1 client configuration:\n\n```kotlin\n// Client factory\nfun createHttpClient(): HttpClient {\n    return HttpClient {\n        install(ContentNegotiation) {\n            json(Json {\n                ignoreUnknownKeys = true\n                isLenient = true\n                encodeDefaults = true\n            })\n        }\n        \n        install(Logging) {\n            logger = Logger.DEFAULT\n            level = LogLevel.INFO\n        }\n        \n        install(HttpTimeout) {\n            requestTimeoutMillis = 30_000\n            connectTimeoutMillis = 10_000\n        }\n        \n        install(Auth) {\n            bearer {\n                loadTokens {\n                    // Load tokens from secure storage\n                    BearerTokens(accessToken, refreshToken)\n                }\n            }\n        }\n        \n        defaultRequest {\n            url(\"https://api.example.com/\")\n            contentType(ContentType.Application.Json)\n        }\n    }\n}\n\n// API Client\nclass ProductApiClient(private val client: HttpClient) {\n    suspend fun getProducts(): List<ProductDto> {\n        return client.get(\"products\").body()\n    }\n    \n    suspend fun createProduct(product: ProductDto): ProductDto {\n        return client.post(\"products\") {\n            setBody(product)\n        }.body()\n    }\n}\n```\n\nALWAYS:\n- Use ContentNegotiation with kotlinx.serialization\n- Add Logging for debugging\n- Set timeouts\n- Use Auth plugin for authentication\n- Use .body() for response parsing (Ktor 3.0+)\n- Handle network errors with try-catch\n\nNEVER:\n- Create multiple HttpClient instances\n- Forget to close HttpClient when done"
    },
    {
      "id": "room-2-7-database",
      "name": "Room 2.7.0 Database (Multiplatform)",
      "filePattern": "**/database/**/*.kt",
      "rule": "Room 2.7.0-alpha10 multiplatform setup:\n\n```kotlin\n// Database\n@Database(entities = [ProductEntity::class, CartItemEntity::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun productDao(): ProductDao\n    abstract fun cartDao(): CartDao\n}\n\n// Entity\n@Entity(tableName = \"products\")\ndata class ProductEntity(\n    @PrimaryKey val id: String,\n    @ColumnInfo(name = \"name\") val name: String,\n    @ColumnInfo(name = \"price\") val price: Double,\n    @ColumnInfo(name = \"image_url\") val imageUrl: String?,\n    @ColumnInfo(name = \"created_at\") val createdAt: Long\n)\n\n// DAO\n@Dao\ninterface ProductDao {\n    @Query(\"SELECT * FROM products WHERE id = :id\")\n    suspend fun getById(id: String): ProductEntity?\n    \n    @Query(\"SELECT * FROM products\")\n    fun observeAll(): Flow<List<ProductEntity>>\n    \n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertAll(products: List<ProductEntity>)\n    \n    @Delete\n    suspend fun delete(product: ProductEntity)\n}\n\n// Database factory (expect/actual)\nexpect object DatabaseFactory {\n    fun create(): RoomDatabase.Builder<AppDatabase>\n}\n\n// Usage\nfun createDatabase(): AppDatabase {\n    return DatabaseFactory.create()\n        .setDriver(BundledSQLiteDriver())\n        .build()\n}\n```\n\nALWAYS:\n- Use @Entity for database tables\n- Use @Dao for data access\n- Use Flow for observable queries\n- Use suspend for single-shot queries\n- Implement expect/actual for database creation\n- Use OnConflictStrategy.REPLACE for upserts\n\nNEVER:\n- Run database operations on main thread\n- Forget @PrimaryKey\n- Use blocking calls (use suspend)"
    },
    {
      "id": "coroutines-1-9-patterns",
      "name": "Coroutines 1.9.0 Patterns",
      "filePattern": "**/*.kt",
      "rule": "Kotlin Coroutines 1.9.0 best practices:\n\n```kotlin\n// In ViewModel\nviewModelScope.launch {\n    // Automatic cancellation when ViewModel is cleared\n}\n\n// Sequential execution\nsuspend fun loadData() {\n    val user = userRepository.getUser()\n    val settings = settingsRepository.getSettings(user.id)\n    return settings\n}\n\n// Parallel execution\nsuspend fun loadDataParallel() = coroutineScope {\n    val user = async { userRepository.getUser() }\n    val products = async { productRepository.getProducts() }\n    Pair(user.await(), products.await())\n}\n\n// Error handling\nsuspend fun safeOperation(): Result<Data> {\n    return try {\n        val data = api.fetchData()\n        Result.success(data)\n    } catch (e: Exception) {\n        Result.failure(e)\n    }\n}\n\n// Flow operators\nfun observeProducts(): Flow<List<Product>> {\n    return productDao.observeAll()\n        .map { entities -> entities.map { it.toDomain() } }\n        .catch { emit(emptyList()) }\n        .flowOn(Dispatchers.IO)\n}\n```\n\nALWAYS:\n- Use viewModelScope in ViewModels\n- Use coroutineScope for structured concurrency\n- Use async/await for parallel operations\n- Use flowOn for Flow context switching\n- Handle cancellation gracefully\n- Use Dispatchers.IO for I/O operations\n- Use Dispatchers.Default for CPU-intensive work\n\nNEVER:\n- Use GlobalScope (except for app-wide singletons)\n- Forget to handle exceptions\n- Block coroutines with Thread.sleep (use delay)\n- Use runBlocking in production code"
    },
    {
      "id": "result-error-handling",
      "name": "Result Wrapper for Error Handling",
      "filePattern": "**/core/util/Result.kt",
      "rule": "Use Kotlin's built-in Result<T> for error handling:\n\n```kotlin\n// In repository\nsuspend fun getProduct(id: String): Result<Product> {\n    return try {\n        val product = api.getProduct(id)\n        Result.success(product)\n    } catch (e: Exception) {\n        Result.failure(e)\n    }\n}\n\n// In ViewModel\nfun loadProduct(id: String) {\n    viewModelScope.launch {\n        productRepository.getProduct(id)\n            .onSuccess { product ->\n                _uiState.value = UiState.Success(product)\n            }\n            .onFailure { error ->\n                _uiState.value = UiState.Error(error.toUiText())\n            }\n    }\n}\n\n// Extension for UI messages\nfun Throwable.toUiText(): UiText {\n    return when (this) {\n        is IOException -> UiText.StringResource(R.string.error_network)\n        is HttpException -> UiText.StringResource(R.string.error_server)\n        else -> UiText.DynamicString(message ?: \"Unknown error\")\n    }\n}\n```\n\nALWAYS:\n- Use Result<T> for operations that can fail\n- Use onSuccess/onFailure for handling\n- Convert exceptions to user-friendly messages\n- Use UiText for string resources\n\nNEVER:\n- Throw exceptions across boundaries\n- Return null for errors (use Result)\n- Ignore errors silently"
    },
    {
      "id": "uitext-localization",
      "name": "UiText for Localization",
      "filePattern": "**/core/util/UiText.kt",
      "rule": "UiText pattern for multiplatform string resources:\n\n```kotlin\nsealed interface UiText {\n    data class DynamicString(val value: String) : UiText\n    data class StringResource(val id: String, val args: List<Any> = emptyList()) : UiText\n}\n\n// Extension for Composable\n@Composable\nfun UiText.asString(): String {\n    return when (this) {\n        is UiText.DynamicString -> value\n        is UiText.StringResource -> stringResource(id, *args.toTypedArray())\n    }\n}\n\n// Usage in ViewModel\ndata class ErrorState(\n    val message: UiText\n)\n\n_uiState.value = ErrorState(\n    message = UiText.StringResource(\"error_network\")\n)\n\n// Usage in Composable\n@Composable\nfun ErrorDialog(error: ErrorState) {\n    Text(error.message.asString())\n}\n```\n\nALWAYS:\n- Use UiText for all user-facing strings\n- Use StringResource for localizable strings\n- Use DynamicString for dynamic content\n\nNEVER:\n- Use hardcoded strings in UI\n- Access resources in ViewModel directly"
    },
    {
      "id": "expect-actual-platform-code",
      "name": "Expect/Actual for Platform-Specific Code",
      "filePattern": "**/*.kt",
      "rule": "Expect/actual mechanism for platform-specific code:\n\n```kotlin\n// In commonMain\nexpect class Logger {\n    fun log(message: String)\n    fun error(message: String, throwable: Throwable?)\n}\n\n// In androidMain\nimport android.util.Log\n\nactual class Logger {\n    actual fun log(message: String) {\n        Log.d(\"AuraFlow\", message)\n    }\n    \n    actual fun error(message: String, throwable: Throwable?) {\n        Log.e(\"AuraFlow\", message, throwable)\n    }\n}\n\n// In iosMain\nimport platform.Foundation.NSLog\n\nactual class Logger {\n    actual fun log(message: String) {\n        NSLog(message)\n    }\n    \n    actual fun error(message: String, throwable: Throwable?) {\n        NSLog(\"ERROR: $message - ${throwable?.message}\")\n    }\n}\n```\n\nALWAYS:\n- Use expect/actual for platform-specific implementations\n- Keep expect declarations minimal\n- Document platform differences\n- Provide actual implementations for all targets\n\nNEVER:\n- Put business logic in actual implementations\n- Use expect/actual excessively (prefer interfaces)"
    },
    {
      "id": "serialization-1-7-3",
      "name": "Kotlinx Serialization 1.7.3",
      "filePattern": "**/dto/**/*.kt",
      "rule": "Kotlinx Serialization 1.7.3 best practices:\n\n```kotlin\n@Serializable\ndata class ProductDto(\n    @SerialName(\"id\") val id: String,\n    @SerialName(\"name\") val name: String,\n    @SerialName(\"price\") val price: Double,\n    @SerialName(\"image_url\") val imageUrl: String? = null,\n    @SerialName(\"created_at\") val createdAt: String\n)\n\n// Custom serializer for date\n@Serializable(with = InstantSerializer::class)\ndata class Timestamp(val value: Instant)\n\nobject InstantSerializer : KSerializer<Timestamp> {\n    override val descriptor = PrimitiveSerialDescriptor(\"Timestamp\", PrimitiveKind.STRING)\n    \n    override fun serialize(encoder: Encoder, value: Timestamp) {\n        encoder.encodeString(value.value.toString())\n    }\n    \n    override fun deserialize(decoder: Decoder): Timestamp {\n        return Timestamp(Instant.parse(decoder.decodeString()))\n    }\n}\n\n// Mapper to domain\nfun ProductDto.toDomain(): Product {\n    return Product(\n        id = id,\n        name = name,\n        price = price,\n        imageUrl = imageUrl,\n        createdAt = Instant.parse(createdAt)\n    )\n}\n```\n\nALWAYS:\n- Use @Serializable on DTOs\n- Use @SerialName for JSON field mapping\n- Provide default values for optional fields\n- Create mappers to/from domain models\n- Use kotlinx-datetime for dates\n\nNEVER:\n- Use @Serializable on domain models\n- Mix DTOs with domain models\n- Forget @SerialName for snake_case fields"
    },
    {
      "id": "testing-best-practices",
      "name": "Testing Best Practices",
      "filePattern": "**/*Test.kt",
      "rule": "Testing patterns for KMP:\n\n```kotlin\n// Use case test\nclass GetProductsUseCaseTest {\n    private val productRepository = mockk<ProductRepository>()\n    private val useCase = GetProductsUseCase(productRepository)\n    \n    @Test\n    fun `should return sorted products`() = runTest {\n        // Given\n        val products = listOf(\n            Product(id = \"1\", name = \"Zebra\", price = 10.0),\n            Product(id = \"2\", name = \"Apple\", price = 5.0)\n        )\n        coEvery { productRepository.getProducts() } returns Result.success(products)\n        \n        // When\n        val result = useCase()\n        \n        // Then\n        result.onSuccess { sorted ->\n            assertEquals(\"Apple\", sorted.first().name)\n            assertEquals(\"Zebra\", sorted.last().name)\n        }\n    }\n}\n\n// ViewModel test with Turbine\nclass POSViewModelTest {\n    @Test\n    fun `should emit loading then success`() = runTest {\n        val repository = mockk<ProductRepository>()\n        coEvery { repository.getProducts() } returns Result.success(testProducts)\n        \n        val viewModel = POSViewModel(repository)\n        \n        viewModel.uiState.test {\n            assertEquals(UiState.Loading, awaitItem())\n            assertEquals(UiState.Success(testProducts), awaitItem())\n        }\n    }\n}\n```\n\nALWAYS:\n- Use runTest for coroutine tests\n- Use mockk for mocking\n- Use Turbine for Flow testing\n- Test use cases and ViewModels\n- Test error cases\n- Use descriptive test names\n\nNEVER:\n- Test implementation details\n- Use real repositories in ViewModel tests"
    },
    {
      "id": "naming-conventions-2025",
      "name": "Naming Conventions (2025)",
      "filePattern": "**/*.kt",
      "rule": "Naming conventions for KMP:\n\n**Classes:**\n- PascalCase: `ProductRepository`, `POSViewModel`\n- Suffix interfaces with contract: `ProductRepository` (not `IProductRepository`)\n- Suffix implementations: `ProductRepositoryImpl`\n- Suffix ViewModels: `POSViewModel`\n- Suffix use cases: `GetProductsUseCase`\n\n**Functions:**\n- camelCase: `getProducts()`, `addToCart()`\n- Use verbs: `load`, `get`, `add`, `update`, `delete`\n- Composables with nouns: `ProductCard`, `CartView`\n\n**Properties:**\n- camelCase: `productList`, `totalPrice`\n- Boolean with `is`/`has`: `isLoading`, `hasError`\n- Private with underscore: `_uiState`\n\n**Constants:**\n- UPPER_SNAKE_CASE: `MAX_RETRY_COUNT`, `API_BASE_URL`\n\n**Packages:**\n- lowercase: `com.theauraflow.pos.domain.model`\n\n**Files:**\n- Match class name: `ProductRepository.kt`\n- Group by feature: `product/ProductRepository.kt`"
    },
    {
      "id": "code-organization-2025",
      "name": "Code Organization (2025)",
      "filePattern": "**/*.kt",
      "rule": "Code organization principles:\n\n**File Structure:**\n```kotlin\n// 1. Package declaration\npackage com.theauraflow.pos.domain.usecase\n\n// 2. Imports (grouped and sorted)\nimport com.theauraflow.pos.domain.model.Product\nimport com.theauraflow.pos.domain.repository.ProductRepository\nimport kotlinx.coroutines.flow.Flow\n\n// 3. Class documentation\n/**\n * Use case for retrieving products.\n * Filters inactive products and sorts by name.\n */\nclass GetProductsUseCase(\n    private val productRepository: ProductRepository\n) {\n    // 4. Public API first\n    suspend operator fun invoke(): Result<List<Product>> {\n        // Implementation\n    }\n    \n    // 5. Private helpers last\n    private fun filterActive(products: List<Product>): List<Product> {\n        return products.filter { it.isActive }\n    }\n}\n```\n\n**Principles:**\n- One class per file\n- Group by feature, not by type\n- Max 300 lines per file\n- Max 50 lines per function\n- Extract complex logic to separate functions\n- Use meaningful names\n- Add KDoc for public API"
    },
    {
      "id": "performance-optimization",
      "name": "Performance Optimization",
      "filePattern": "**/*.kt",
      "rule": "Performance best practices:\n\n**Compose:**\n```kotlin\n// Use remember for expensive calculations\n@Composable\nfun ProductList(products: List<Product>) {\n    val sortedProducts = remember(products) {\n        products.sortedBy { it.name }\n    }\n}\n\n// Use key for LazyColumn items\nLazyColumn {\n    items(\n        items = products,\n        key = { it.id }\n    ) { product ->\n        ProductCard(product)\n    }\n}\n\n// Use derivedStateOf for derived values\nval hasItems by remember {\n    derivedStateOf { cart.items.isNotEmpty() }\n}\n```\n\n**Coroutines:**\n```kotlin\n// Use Flow for streams\nfun observeProducts(): Flow<List<Product>> {\n    return productDao.observeAll()\n        .map { it.map { entity -> entity.toDomain() } }\n        .flowOn(Dispatchers.IO)\n}\n\n// Use conflate for high-frequency emissions\nfun observeLocation(): Flow<Location> {\n    return locationProvider.updates\n        .conflate()\n}\n```\n\nALWAYS:\n- Use LazyColumn/LazyRow for lists\n- Provide keys for list items\n- Use remember for expensive calculations\n- Use flowOn for Flow context\n- Cache network responses\n- Optimize images (Coil handles this)\n\nNEVER:\n- Create new objects in Composable body\n- Use !! operator\n- Block main thread"
    },
    {
      "id": "security-best-practices",
      "name": "Security Best Practices",
      "filePattern": "**/*.kt",
      "rule": "Security guidelines:\n\n```kotlin\n// Store tokens securely (expect/actual)\nexpect class SecureStorage {\n    suspend fun saveToken(key: String, value: String)\n    suspend fun getToken(key: String): String?\n    suspend fun deleteToken(key: String)\n}\n\n// Use HTTPS only\nfun createHttpClient(): HttpClient {\n    return HttpClient {\n        defaultRequest {\n            url.protocol = URLProtocol.HTTPS\n        }\n    }\n}\n\n// Sanitize user input\nfun sanitizeInput(input: String): String {\n    return input.trim()\n        .replace(\"<\", \"&lt;\")\n        .replace(\">\", \"&gt;\")\n}\n\n// Don't log sensitive data\nLogger.log(\"User logged in\") // Good\nLogger.log(\"Token: $token\") // BAD!\n```\n\nALWAYS:\n- Use HTTPS\n- Store tokens securely\n- Validate user input\n- Use ProGuard/R8\n- Handle permissions properly\n\nNEVER:\n- Hardcode API keys\n- Log sensitive data\n- Store passwords in plain text\n- Trust client-side validation"
    },
    {
      "id": "documentation-standards",
      "name": "Documentation Standards",
      "filePattern": "**/*.kt",
      "rule": "Documentation guidelines:\n\n```kotlin\n/**\n * Repository for managing product data.\n * \n * Implements offline-first pattern:\n * 1. Try to fetch from remote API\n * 2. Cache results locally\n * 3. Fallback to local cache on network error\n * \n * @property remoteDataSource Remote API client\n * @property localDataSource Local database access\n */\nclass ProductRepositoryImpl(\n    private val remoteDataSource: ProductRemoteDataSource,\n    private val localDataSource: ProductLocalDataSource\n) : ProductRepository {\n    \n    /**\n     * Retrieves all products.\n     * \n     * @return Result containing list of products or error\n     */\n    override suspend fun getProducts(): Result<List<Product>> {\n        // Implementation\n    }\n}\n```\n\nALWAYS:\n- Add KDoc for public APIs\n- Explain complex logic\n- Document assumptions\n- Link to related code\n- Keep docs updated\n\nNEVER:\n- Document obvious code\n- Copy-paste comments\n- Leave TODO without ticket"
    },
    {
      "id": "full-stack-kmp-architecture",
      "name": "Full-Stack KMP Architecture (Client + Server)",
      "description": "Architecture for full-stack Kotlin Multiplatform application with Ktor Server and shared code between client and server.",
      "trigger": "When building full-stack KMP applications with client (Android, iOS, Desktop, Web) and Ktor Server",
      "recommendation": "Use Ktor Server for backend, share DTOs/models between client and server, implement clean architecture on both sides.",
      "example": "// Project structure:\n// - shared/       (Client shared code: UI, ViewModels, UseCases, Repositories, DTOs)\n// - server/        (Ktor Server: API endpoints, database, business logic)\n// - commonModels/  (Shared DTOs/Models between client and server)\n// - androidApp/\n// - iosApp/\n// - desktopApp/\n// - webApp/\n\n// Common DTOs (shared between client and server):\n@Serializable\ndata class ProductDto(\n    val id: String,\n    val name: String,\n    val price: Double,\n    val category: String\n)\n\n// Server-side repository:\nclass ProductRepository(private val database: Database) {\n    fun getProducts(): List<ProductDto> = transaction {\n        ProductTable.selectAll().map { it.toDto() }\n    }\n}\n\n// Client-side repository:\nclass ProductRepository(private val api: ProductApi, private val cache: ProductCache) {\n    suspend fun getProducts(): Result<List<ProductDto>> = safeApiCall {\n        api.getProducts().also { cache.saveProducts(it) }\n    }\n}",
      "avoid": "Don't duplicate models. Share DTOs in a common module. Don't put UI code in server module."
    },
    {
      "id": "ktor-server-setup",
      "name": "Ktor Server 3.3.1 Setup",
      "description": "Best practices for setting up Ktor Server with proper plugins and configuration.",
      "trigger": "When setting up Ktor Server or configuring server modules",
      "recommendation": "Use Ktor 3.3.1, configure proper plugins (ContentNegotiation, CORS, StatusPages, Authentication), use application.conf for config.",
      "example": "// build.gradle.kts (server module):\ndependencies {\n    implementation(\"io.ktor:ktor-server-core:3.3.1\")\n    implementation(\"io.ktor:ktor-server-netty:3.3.1\")\n    implementation(\"io.ktor:ktor-server-content-negotiation:3.3.1\")\n    implementation(\"io.ktor:ktor-serialization-kotlinx-json:3.3.1\")\n    implementation(\"io.ktor:ktor-server-cors:3.3.1\")\n    implementation(\"io.ktor:ktor-server-status-pages:3.3.1\")\n    implementation(\"io.ktor:ktor-server-auth:3.3.1\")\n    implementation(\"io.ktor:ktor-server-auth-jwt:3.3.1\")\n    implementation(\"io.ktor:ktor-server-websockets:3.3.1\")\n}\n\n// Application.kt:\nfun Application.module() {\n    install(ContentNegotiation) {\n        json(Json {\n            prettyPrint = true\n            isLenient = true\n            ignoreUnknownKeys = true\n        })\n    }\n    \n    install(CORS) {\n        anyHost()\n        allowHeader(HttpHeaders.ContentType)\n        allowHeader(HttpHeaders.Authorization)\n    }\n    \n    install(StatusPages) {\n        exception<Throwable> { call, cause ->\n            call.respond(HttpStatusCode.InternalServerError, ErrorResponse(cause.message))\n        }\n    }\n    \n    configureRouting()\n    configureAuth()\n}",
      "avoid": "Don't hardcode secrets. Don't expose stack traces to clients. Don't skip error handling."
    },
    {
      "id": "exposed-orm-patterns",
      "name": "Exposed ORM Best Practices",
      "description": "Use Exposed ORM for database access with proper transaction management and type-safe queries.",
      "trigger": "When implementing database access layer with Exposed ORM",
      "recommendation": "Use Exposed 0.58.0+, implement DAO pattern, use proper transaction blocks, handle errors gracefully.",
      "example": "// Dependencies:\n// implementation(\"org.jetbrains.exposed:exposed-core:0.58.0\")\n// implementation(\"org.jetbrains.exposed:exposed-dao:0.58.0\")\n// implementation(\"org.jetbrains.exposed:exposed-jdbc:0.58.0\")\n// implementation(\"org.jetbrains.exposed:exposed-kotlin-datetime:0.58.0\")\n\n// Table definition:\nobject ProductsTable : Table(\"products\") {\n    val id = varchar(\"id\", 36)\n    val name = varchar(\"name\", 255)\n    val price = decimal(\"price\", 10, 2)\n    val category = varchar(\"category\", 100)\n    val createdAt = datetime(\"created_at\")\n    override val primaryKey = PrimaryKey(id)\n}\n\n// DAO:\nclass ProductDao(id: EntityID<String>) : Entity<String>(id) {\n    companion object : EntityClass<String, ProductDao>(ProductsTable)\n    var name by ProductsTable.name\n    var price by ProductsTable.price\n    var category by ProductsTable.category\n    var createdAt by ProductsTable.createdAt\n}\n\n// Repository:\nclass ProductRepository(private val database: Database) {\n    suspend fun getProducts(): Result<List<ProductDto>> = dbQuery {\n        ProductDao.all().map { it.toDto() }\n    }\n    \n    suspend fun createProduct(dto: CreateProductDto): Result<ProductDto> = dbQuery {\n        ProductDao.new(UUID.randomUUID().toString()) {\n            name = dto.name\n            price = dto.price\n            category = dto.category\n            createdAt = Clock.System.now().toLocalDateTime(TimeZone.UTC)\n        }.toDto()\n    }\n}\n\n// Transaction helper:\nsuspend fun <T> dbQuery(block: suspend () -> T): Result<T> = withContext(Dispatchers.IO) {\n    try {\n        Result.success(transaction { block() })\n    } catch (e: Exception) {\n        Result.failure(DatabaseException(e.message, e))\n    }\n}",
      "avoid": "Don't use raw SQL unless necessary. Don't forget transaction blocks. Don't expose database entities directly."
    },
    {
      "id": "jwt-authentication",
      "name": "JWT Authentication with Ktor",
      "description": "Implement secure JWT-based authentication for Ktor Server.",
      "trigger": "When implementing authentication and authorization",
      "recommendation": "Use ktor-server-auth-jwt, implement proper token generation/validation, use refresh tokens, secure secrets.",
      "example": "// JWT Config:\nobject JwtConfig {\n    private val secret = System.getenv(\"JWT_SECRET\")\n    private val issuer = \"auraflow-pos\"\n    private val audience = \"auraflow-clients\"\n    const val realm = \"AuraFlow POS\"\n    \n    val verifier: JWTVerifier = JWT\n        .require(Algorithm.HMAC256(secret))\n        .withAudience(audience)\n        .withIssuer(issuer)\n        .build()\n    \n    fun generateToken(userId: String): String = JWT.create()\n        .withAudience(audience)\n        .withIssuer(issuer)\n        .withClaim(\"userId\", userId)\n        .withExpiresAt(Date(System.currentTimeMillis() + 3600000)) // 1 hour\n        .sign(Algorithm.HMAC256(secret))\n}\n\n// Install authentication:\nfun Application.configureAuth() {\n    install(Authentication) {\n        jwt(\"auth-jwt\") {\n            realm = JwtConfig.realm\n            verifier(JwtConfig.verifier)\n            validate { credential ->\n                if (credential.payload.getClaim(\"userId\").asString() != \"\") {\n                    JWTPrincipal(credential.payload)\n                } else null\n            }\n            challenge { _, _ ->\n                call.respond(HttpStatusCode.Unauthorized, \"Invalid or expired token\")\n            }\n        }\n    }\n}\n\n// Protected route:\nroute(\"/api/protected\") {\n    authenticate(\"auth-jwt\") {\n        get(\"/products\") {\n            val principal = call.principal<JWTPrincipal>()\n            val userId = principal?.payload?.getClaim(\"userId\")?.asString()\n            // Handle request\n        }\n    }\n}",
      "avoid": "Don't store secrets in code. Don't use weak algorithms. Don't make tokens too long-lived without refresh mechanism."
    },
    {
      "id": "websocket-real-time",
      "name": "WebSocket for Real-Time Updates",
      "description": "Implement WebSocket connections for real-time data synchronization across POS terminals.",
      "trigger": "When implementing real-time features like order updates, inventory sync, etc.",
      "recommendation": "Use Ktor WebSockets, implement proper connection management, handle reconnection, use message serialization.",
      "example": "// Server-side WebSocket:\nfun Application.configureWebSockets() {\n    install(WebSockets) {\n        pingPeriod = Duration.ofSeconds(15)\n        timeout = Duration.ofSeconds(15)\n        maxFrameSize = Long.MAX_VALUE\n        masking = false\n    }\n    \n    routing {\n        webSocket(\"/ws/orders\") {\n            val userId = call.principal<JWTPrincipal>()?.payload?.getClaim(\"userId\")?.asString()\n            if (userId == null) {\n                close(CloseReason(CloseReason.Codes.VIOLATED_POLICY, \"Not authenticated\"))\n                return@webSocket\n            }\n            \n            // Add connection to pool\n            connections[userId] = this\n            \n            try {\n                for (frame in incoming) {\n                    when (frame) {\n                        is Frame.Text -> {\n                            val message = Json.decodeFromString<WSMessage>(frame.readText())\n                            handleMessage(userId, message)\n                        }\n                    }\n                }\n            } finally {\n                connections.remove(userId)\n            }\n        }\n    }\n}\n\n// Broadcast to all connected clients:\nsuspend fun broadcastOrderUpdate(order: OrderDto) {\n    val message = WSMessage(\n        type = \"ORDER_UPDATE\",\n        data = Json.encodeToString(order)\n    )\n    connections.values.forEach { session ->\n        session.send(Frame.Text(Json.encodeToString(message)))\n    }\n}\n\n// Client-side WebSocket (in shared KMP code):\nclass WebSocketClient(private val httpClient: HttpClient) {\n    private var session: DefaultClientWebSocketSession? = null\n    \n    suspend fun connect(token: String) {\n        session = httpClient.webSocketSession {\n            url(\"ws://localhost:8080/ws/orders\")\n            header(\"Authorization\", \"Bearer $token\")\n        }\n        \n        session?.incoming?.consumeEach { frame ->\n            when (frame) {\n                is Frame.Text -> handleMessage(frame.readText())\n            }\n        }\n    }\n}",
      "avoid": "Don't forget authentication. Don't hold references to closed sessions. Don't send large payloads without chunking."
    }
  ]
}
